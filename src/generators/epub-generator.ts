import type { Config } from "../types/config.types";
import type {
  EPUBGenerationOptions,
  GenerationResult,
} from "../types/output.types";
import type { ProcessedFile } from "../types/file.types";
import { logger } from "../utils/logger";
import fs from "fs";
import Epub from "epub-gen";

/**
 * Generator for EPUB output
 */
export class EPUBGenerator {
  private config: Config;

  constructor(config: Config) {
    this.config = config;
  }

  /**
   * Generate EPUB from processed files
   */
  public async generateEPUB(
    files: ProcessedFile[],
    repoInfo: { name: string; description?: string; url: string },
    outputPath: string,
  ): Promise<GenerationResult> {
    const startTime = Date.now();

    try {
      // Set EPUB options
      const { style } = this.config;
      const epubOptions: EPUBGenerationOptions = {
        includeTableOfContents: style.includeTableOfContents,
        includeLineNumbers: style.lineNumbers,
        theme: style.theme,
        customCSS: style.customCSS,
        title: repoInfo.name,
        author: "repo2pdf",
        publisher: "repo2pdf",
      };

      // Organize files by directory
      const filesByDirectory = this.organizeFilesByDirectory(files);

      // Generate EPUB content
      const content = this.generateEPUBContent(filesByDirectory, epubOptions);

      // Generate EPUB
      await new Epub({
        title: repoInfo.name,
        author: "Generated by repo2pdf",
        publisher: "repo2pdf",
        cover: this.generateCoverImage(repoInfo.name),
        content,
        css: this.generateCSS(epubOptions.theme, epubOptions.customCSS),
        tocTitle: "Table of Contents",
        appendChapterTitles: false,
        customHtmlTocTemplatePath: epubOptions.includeTableOfContents
          ? this.generateCustomTOC(filesByDirectory)
          : undefined,
      }).promise.then(() => {
        logger.info(`EPUB generated successfully: ${outputPath}`);
      });

      // Get file size
      const stats = fs.statSync(outputPath);

      return {
        success: true,
        outputPath,
        format: "epub",
        fileSize: stats.size,
        generationTime: Date.now() - startTime,
      };
    } catch (error) {
      logger.error("Error generating EPUB:", error);
      throw new Error(`Failed to generate EPUB: ${(error as Error).message}`);
    }
  }

  /**
   * Organize files by directory
   */
  private organizeFilesByDirectory(
    files: ProcessedFile[],
  ): Record<string, ProcessedFile[]> {
    const directories: Record<string, ProcessedFile[]> = {};

    for (const file of files) {
      const dirPath = file.path.includes("/")
        ? file.path.substring(0, file.path.lastIndexOf("/"))
        : "";

      if (!directories[dirPath]) {
        directories[dirPath] = [];
      }

      directories[dirPath].push(file);
    }

    // Sort directories and files
    const sortedDirectories: Record<string, ProcessedFile[]> = {};

    Object.keys(directories)
      .sort((a, b) => a.localeCompare(b))
      .forEach((dir) => {
        sortedDirectories[dir] = directories[dir].sort((a, b) =>
          a.name.localeCompare(b.name),
        );
      });

    return sortedDirectories;
  }

  /**
   * Generate EPUB content
   */
  private generateEPUBContent(
    filesByDirectory: Record<string, ProcessedFile[]>,
    options: EPUBGenerationOptions,
  ): Array<{ title: string; content: string }> {
    const content: Array<{ title: string; content: string }> = [];

    // Add cover page
    content.push({
      title: "Cover",
      content: `
        <div class="cover">
          <h1>${options.title}</h1>
          <p>Generated by repo2pdf</p>
          <p>Date: ${new Date().toLocaleDateString()}</p>
        </div>
      `,
    });

    // Process root files first
    if (filesByDirectory[""]) {
      filesByDirectory[""].forEach((file) => {
        content.push({
          title: file.name,
          content: this.generateFileHtml(file, options),
        });
      });
    }

    // Process directories
    Object.keys(filesByDirectory)
      .filter((dir) => dir !== "")
      .forEach((dir) => {
        // Add directory as a chapter
        content.push({
          title: `${dir}/`,
          content: `<h1>${this.escapeHtml(dir)}/</h1>`,
        });

        // Add files in this directory
        filesByDirectory[dir].forEach((file) => {
          content.push({
            title: file.name,
            content: this.generateFileHtml(file, options),
          });
        });
      });

    return content;
  }

  /**
   * Generate HTML for a single file
   */
  private generateFileHtml(
    file: ProcessedFile,
    options: EPUBGenerationOptions,
  ): string {
    let html = `
      <div class="file-container">
        <div class="file-header">
          <div class="file-path">${this.escapeHtml(file.path)}</div>
          <div class="file-meta">${this.formatFileSize(file.size)}</div>
        </div>
    `;

    // Generate content based on file type
    if (file.type === "code" && file.highlightedHtml) {
      html += `
        <div class="file-content">
          ${file.highlightedHtml}
        </div>
      `;
    } else if (file.type === "image" && file.base64Content) {
      html += `
        <div class="image-container">
          <img src="${file.base64Content}" alt="${this.escapeHtml(file.name)}" />
        </div>
      `;
    } else if (file.type === "binary" || file.type === "unknown") {
      html += `
        <div class="binary-info">
          ${this.escapeHtml(file.processedContent)}
        </div>
      `;
    } else {
      html += `
        <div class="file-content">
          <pre><code>${this.escapeHtml(file.processedContent)}</code></pre>
        </div>
      `;
    }

    html += `
      </div>
    `;

    return html;
  }

  /**
   * Generate CSS styles
   */
  private generateCSS(theme: string, customCSS?: string): string {
    return `
      .cover {
        text-align: center;
        padding: 20% 0;
      }
      
      .cover h1 {
        font-size: 2em;
        margin-bottom: 2em;
      }
      
      .file-container {
        margin-bottom: 2em;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow: hidden;
      }
      
      .file-header {
        background-color: ${theme === "dark" ? "#333" : "#f5f5f5"};
        padding: 0.5em 1em;
        border-bottom: 1px solid #ddd;
      }
      
      .file-path {
        font-family: monospace;
        font-weight: bold;
      }
      
      .file-meta {
        font-size: 0.9em;
        color: #666;
      }
      
      .file-content {
        padding: 1em;
      }
      
      .file-content pre {
        margin: 0;
        white-space: pre-wrap;
      }
      
      .file-content code {
        font-family: monospace;
        font-size: 0.9em;
      }
      
      .image-container {
        padding: 1em;
        text-align: center;
      }
      
      .image-container img {
        max-width: 100%;
      }
      
      .binary-info {
        padding: 1em;
        text-align: center;
        font-style: italic;
      }
      
      ${customCSS || ""}
    `;
  }

  /**
   * Generate a cover image (placeholder)
   */
  private generateCoverImage(title: string): string {
    // In a real implementation, this would generate a cover image
    // For now, return an empty string to use the default cover
    return "";
  }

  /**
   * Generate custom table of contents
   */
  private generateCustomTOC(
    filesByDirectory: Record<string, ProcessedFile[]>,
  ): string {
    // In a real implementation, this would generate a custom TOC template
    // For now, return an empty string to use the default TOC
    return "";
  }

  /**
   * Format file size in human-readable format
   */
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return "0 Bytes";

    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return (
      Number.parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
    );
  }

  /**
   * Escape HTML special characters
   */
  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }
}
